
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photobooth 2026 - Fix</title>
    <link rel="stylesheet" href="style.css">
    <style>
      
    </style>
</head>
<body>

<div class="main-container">
    <div class="sidebar">
        <h3 class="label-control">CONTROLS</h3>
        <div id="slot-list">
            <div class="slot-btn active" onclick="selectSlot(0)">PHOTO 1</div>
            <div class="slot-btn" onclick="selectSlot(1)">PHOTO 2</div>
            <div class="slot-btn" onclick="selectSlot(2)">PHOTO 3</div>
            <div class="slot-btn" onclick="selectSlot(3)">PHOTO 4</div>
        </div>

        <input type="file" id="fileInput" style="display:none" onchange="handleFile(event)">
        <button class="btn" onclick="document.getElementById('fileInput').click()">UPLOAD PHOTO</button>

        <div class="controls">
            <label id="zoom-label">ZOOM: FRAME 1</label>
            <input type="range" id="zoomRange" step="0.001" value="1">
            <button class="btn" style="background:#555" onclick="resetActive()">FIT IMAGE</button>
        </div>

        <button class="btn btn-download" onclick="download()">DOWNLOAD FINAL</button>
    </div>

    <div class="viewport">
        <canvas id="boothCanvas" width="1080" height="720"></canvas>
        <p style="color: #666; font-size: 12px; margin-top: 10px;">Click frames directly to select. Drag to move.</p>
    </div>
</div>

<script>
    const canvas = document.getElementById('boothCanvas');
    const ctx = canvas.getContext('2d');
    const zoomRange = document.getElementById('zoomRange');
    
    const template = new Image();
    template.src = 'photobooth.png';
    let templateLoaded = false;
    template.onload = () => { templateLoaded = true; render(); };

    let activeIdx = 0;
    let photos = [null, null, null, null];

    const slots = [
        { x: 45,  y: 42,  w: 605, h: 366 }, 
        { x: 40,  y: 455, w: 317, h: 206 }, 
        { x: 382, y: 455, w: 317, h: 206 }, 
        { x: 723, y: 455, w: 317, h: 206 }  
    ];
    let states = slots.map(s => ({ x: s.x, y: s.y, scale: 1, minScale: 1 }));

    function render() {
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        photos.forEach((img, i) => {
            ctx.save();
            ctx.beginPath();
            ctx.rect(slots[i].x, slots[i].y, slots[i].w, slots[i].h);
            ctx.clip();

            if(img) {
                const s = states[i];
                ctx.drawImage(img, s.x, s.y, img.width * s.scale, img.height * s.scale);
            } else {
                ctx.fillStyle = "#222";
                ctx.fillRect(slots[i].x, slots[i].y, slots[i].w, slots[i].h);
                ctx.fillStyle = (i === activeIdx) ? "#009dff" : "#444";
                ctx.font = "bold 20px Arial";
                ctx.textAlign = "center";
                ctx.fillText("TAP TO UPLOAD", slots[i].x + slots[i].w/2, slots[i].y + slots[i].h/2);
            }
            ctx.restore();

            if (i === activeIdx && activeIdx !== -1) {
                ctx.strokeStyle = "#009dff";
                ctx.lineWidth = 4;
                ctx.strokeRect(slots[i].x, slots[i].y, slots[i].w, slots[i].h);
            }
        });

        if(templateLoaded) ctx.drawImage(template, 0, 0, canvas.width, canvas.height);
    }

    function selectSlot(i) {
        activeIdx = i;
        document.querySelectorAll('.slot-btn').forEach((b,idx) => b.classList.toggle('active', idx===i));
        zoomRange.min = states[i].minScale;
        zoomRange.max = states[i].minScale * 4;
        zoomRange.value = states[i].scale;
        render();
    }

    function handleFile(e) {
        const file = e.target.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = (f) => {
            const img = new Image();
            img.onload = () => {
                photos[activeIdx] = img;
                const minS = Math.max(slots[activeIdx].w / img.width, slots[activeIdx].h / img.height);
                states[activeIdx].minScale = minS;
                states[activeIdx].scale = minS;
                states[activeIdx].x = slots[activeIdx].x;
                states[activeIdx].y = slots[activeIdx].y;
                selectSlot(activeIdx);
            };
            img.src = f.target.result;
        };
        reader.readAsDataURL(file);
    }

    function constrain(idx) {
        const s = states[idx], slot = slots[idx], img = photos[idx];
        if(!img) return;
        const w = img.width * s.scale, h = img.height * s.scale;
        if (s.x > slot.x) s.x = slot.x;
        if (s.x + w < slot.x + slot.w) s.x = slot.x + slot.w - w;
        if (s.y > slot.y) s.y = slot.y;
        if (s.y + h < slot.y + slot.h) s.y = slot.y + slot.h - h;
    }

    const getP = (e) => {
        const r = canvas.getBoundingClientRect();
        const tx = e.touches ? e.touches[0].clientX : (e.clientX || e.pageX);
        const ty = e.touches ? e.touches[0].clientY : (e.clientY || e.pageY);
        return { x: (tx - r.left) * (1080 / r.width), y: (ty - r.top) * (720 / r.height) };
    };

    // --- MOBILE & DESKTOP FIXED CLICK LOGIC ---
    let isDragging = false;
    let startX, startY;
    let lastMouseX, lastMouseY;

    canvas.addEventListener('pointerdown', (e) => {
        const p = getP(e);
        startX = p.x;
        startY = p.y;
        lastMouseX = p.x;
        lastMouseY = p.y;
        isDragging = true;

        // Immediately check if we hit a slot to make it active
        slots.forEach((s, i) => {
            if(p.x > s.x && p.x < s.x+s.w && p.y > s.y && p.y < s.y+s.h) {
                selectSlot(i);
            }
        });
    });

    window.addEventListener('pointermove', (e) => {
        if (!isDragging || !photos[activeIdx]) return;
        const p = getP(e);
        states[activeIdx].x += (p.x - lastMouseX);
        states[activeIdx].y += (p.y - lastMouseY);
        constrain(activeIdx);
        lastMouseX = p.x;
        lastMouseY = p.y;
        render();
    });

    window.addEventListener('pointerup', (e) => {
        if (!isDragging) return;
        const p = getP(e);
        
        // Calculate distance moved
        const dist = Math.sqrt(Math.pow(p.x - startX, 2) + Math.pow(p.y - startY, 2));
        
        // If the user tapped (hardly moved) and frame is empty or active, upload!
        if (dist < 5) {
            slots.forEach((s, i) => {
                if(p.x > s.x && p.x < s.x+s.w && p.y > s.y && p.y < s.y+s.h) {
                    // Triggers file input
                    document.getElementById('fileInput').click();
                }
            });
        }
        
        isDragging = false;
    });

    zoomRange.oninput = (e) => {
        const s = states[activeIdx], slot = slots[activeIdx];
        const oldS = s.scale;
        s.scale = parseFloat(e.target.value);
        s.x = (slot.x + slot.w/2) - ((slot.x + slot.w/2) - s.x) * (s.scale / oldS);
        s.y = (slot.y + slot.h/2) - ((slot.y + slot.h/2) - s.y) * (s.scale / oldS);
        constrain(activeIdx);
        render();
    };

    function resetActive() { 
        if(photos[activeIdx]) {
            const minS = Math.max(slots[activeIdx].w / photos[activeIdx].width, slots[activeIdx].h / photos[activeIdx].height);
            states[activeIdx].scale = minS;
            states[activeIdx].x = slots[activeIdx].x;
            states[activeIdx].y = slots[activeIdx].y;
            selectSlot(activeIdx);
        }
    }

    function download() {
        const old = activeIdx; activeIdx = -1; render();
        setTimeout(() => {
            const link = document.createElement('a');
            link.download = 'photobooth_2026.png';
            link.href = canvas.toDataURL();
            link.click();
            activeIdx = old; render();
        }, 100);
    }

    render();
</script>
</body>
</html>
