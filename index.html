<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photobooth 2026 - Fix</title>
    <link rel="stylesheet" href="style.css">
    <style>
      
    </style>
</head>
<body>

<div class="main-container">
    <div class="sidebar">
        <h3 class="label-control">CONTROLS</h3>
        <div id="slot-list">
            <div class="slot-btn active" onclick="selectSlot(0)">PHOTO 1</div>
            <div class="slot-btn" onclick="selectSlot(1)">PHOTO 2</div>
            <div class="slot-btn" onclick="selectSlot(2)">PHOTO 3</div>
            <div class="slot-btn" onclick="selectSlot(3)">PHOTO 4</div>
        </div>

        <input type="file" id="fileInput" style="display:none" onchange="handleFile(event)">
        <button class="btn" onclick="document.getElementById('fileInput').click()">UPLOAD PHOTO</button>

        <div class="controls">
            <label id="zoom-label">ZOOM: FRAME 1</label>
            <input type="range" id="zoomRange" step="0.001" value="1">
            <button class="btn" style="background:#555" onclick="resetActive()">FIT IMAGE</button>
        </div>

        <button class="btn btn-download" onclick="download()">DOWNLOAD FINAL</button>
    </div>

    <div class="viewport">
        <canvas id="boothCanvas" width="1080" height="720"></canvas>
        <p style="color: #666; font-size: 12px; margin-top: 10px;">Click frames directly to select. Drag to move.</p>
    </div>
</div>

<script>
    const canvas = document.getElementById('boothCanvas');
    const ctx = canvas.getContext('2d');
    const zoomRange = document.getElementById('zoomRange');
    
    // Load Template
    const template = new Image();
    template.src = 'photobooth.png';
    let templateLoaded = false;
    template.onload = () => { templateLoaded = true; render(); };
    template.onerror = () => { console.error("photobooth.png not found. Using fallback."); render(); };

    let activeIdx = 0;
    let photos = [null, null, null, null];

    // Frame Coordinates (X, Y, Width, Height)
    const slots = [
        { x: 45,  y: 42,  w: 605, h: 366 }, // Big Photo
        { x: 40,  y: 455, w: 317, h: 206 }, // Small 1
        { x: 382, y: 455, w: 317, h: 206 }, // Small 2
        { x: 723, y: 455, w: 317, h: 206 }  // Small 3
    ];
    let states = slots.map(s => ({ x: s.x, y: s.y, scale: 1, minScale: 1 }));

    function render() {
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // 1. Draw Uploaded Images
        photos.forEach((img, i) => {
            ctx.save();
            ctx.beginPath();
            ctx.rect(slots[i].x, slots[i].y, slots[i].w, slots[i].h);
            ctx.clip();

            if(img) {
                const s = states[i];
                ctx.drawImage(img, s.x, s.y, img.width * s.scale, img.height * s.scale);
            } else {
                ctx.fillStyle = "#222";
                ctx.fillRect(slots[i].x, slots[i].y, slots[i].w, slots[i].h);
                ctx.fillStyle = (i === activeIdx) ? "#009dff" : "#444";
                ctx.font = "bold 20px Arial";
                ctx.textAlign = "center";
                ctx.fillText("CLICK TO UPLOAD", slots[i].x + slots[i].w/2, slots[i].y + slots[i].h/2);
            }
            ctx.restore();

            // Active Frame Highlight
            if (i === activeIdx) {
                ctx.strokeStyle = "#009dff";
                ctx.lineWidth = 4;
                ctx.strokeRect(slots[i].x, slots[i].y, slots[i].w, slots[i].h);
            }
        });

        // 2. Draw Template
        if(templateLoaded) {
            ctx.drawImage(template, 0, 0, canvas.width, canvas.height);
        } else {
            // Placeholder frame if image fails
            ctx.strokeStyle = "white";
            ctx.lineWidth = 2;
            ctx.strokeRect(5, 5, canvas.width-10, canvas.height-10);
            ctx.fillStyle = "white";
            ctx.fillText("TEMPLATE OVERLAY MISSING", 800, 50);
        }
    }

    // --- Logic for selection, upload, and scaling ---

    function selectSlot(i) {
        activeIdx = i;
        document.querySelectorAll('.slot-btn').forEach((b,idx) => b.classList.toggle('active', idx===i));
        zoomRange.min = states[i].minScale;
        zoomRange.max = states[i].minScale * 4;
        zoomRange.value = states[i].scale;
        render();
    }

    function handleFile(e) {
        const file = e.target.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = (f) => {
            const img = new Image();
            img.onload = () => {
                photos[activeIdx] = img;
                // Calculate Fit
                const minS = Math.max(slots[activeIdx].w / img.width, slots[activeIdx].h / img.height);
                states[activeIdx].minScale = minS;
                states[activeIdx].scale = minS;
                states[activeIdx].x = slots[activeIdx].x;
                states[activeIdx].y = slots[activeIdx].y;
                selectSlot(activeIdx);
            };
            img.src = f.target.result;
        };
        reader.readAsDataURL(file);
    }

    function constrain(idx) {
        const s = states[idx], slot = slots[idx], img = photos[idx];
        if(!img) return;
        const w = img.width * s.scale, h = img.height * s.scale;
        if (s.x > slot.x) s.x = slot.x;
        if (s.x + w < slot.x + slot.w) s.x = slot.x + slot.w - w;
        if (s.y > slot.y) s.y = slot.y;
        if (s.y + h < slot.y + slot.h) s.y = slot.y + slot.h - h;
    }

    // Interaction Events
    const getP = (e) => {
        const r = canvas.getBoundingClientRect();
        const tx = e.touches ? e.touches[0].clientX : e.clientX;
        const ty = e.touches ? e.touches[0].clientY : e.clientY;
        return { x: (tx - r.left) * (1080 / r.width), y: (ty - r.top) * (720 / r.height) };
    };

    canvas.addEventListener('mousedown', (e) => {
        const p = getP(e);
        slots.forEach((s, i) => {
            if(p.x > s.x && p.x < s.x+s.w && p.y > s.y && p.y < s.y+s.h) {
                selectSlot(i);
                if(!photos[i]) document.getElementById('fileInput').click();
            }
        });
    });

    let down = false, lx, ly;
    const onStart = (e) => { down = true; const p = getP(e); lx = p.x; ly = p.y; };
    const onMove = (e) => {
        if(!down || !photos[activeIdx]) return;
        const p = getP(e);
        states[activeIdx].x += (p.x - lx);
        states[activeIdx].y += (p.y - ly);
        constrain(activeIdx);
        lx = p.x; ly = p.y;
        render();
    };

    canvas.addEventListener('mousedown', onStart);
    window.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', () => down = false);
    canvas.addEventListener('touchstart', (e) => { e.preventDefault(); onStart(e); }, {passive:false});
    canvas.addEventListener('touchmove', (e) => { e.preventDefault(); onMove(e); }, {passive:false});
    canvas.addEventListener('touchend', () => down = false);

    zoomRange.oninput = (e) => {
        const s = states[activeIdx], slot = slots[activeIdx];
        const oldS = s.scale;
        s.scale = parseFloat(e.target.value);
        s.x = (slot.x + slot.w/2) - ((slot.x + slot.w/2) - s.x) * (s.scale / oldS);
        s.y = (slot.y + slot.h/2) - ((slot.y + slot.h/2) - s.y) * (s.scale / oldS);
        constrain(activeIdx);
        render();
    };

    function resetActive() { if(photos[activeIdx]) {
        const minS = Math.max(slots[activeIdx].w / photos[activeIdx].width, slots[activeIdx].h / photos[activeIdx].height);
        states[activeIdx].scale = minS;
        states[activeIdx].x = slots[activeIdx].x;
        states[activeIdx].y = slots[activeIdx].y;
        selectSlot(activeIdx);
    }}

    function download() {
        const old = activeIdx; activeIdx = -1; render();
        setTimeout(() => {
            const link = document.createElement('a');
            link.download = 'photobooth_2026.png';
            link.href = canvas.toDataURL();
            link.click();
            activeIdx = old; render();
        }, 100);
    }

    render();
</script>

</body>
</html>